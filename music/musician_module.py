"""The class defining the concept of musician
"""


#%%
class Musician:
    """The class describing the concept of musician.
    It is assumed that a musician is sufficiently described by their
    name and whether they are a solo musician or a member of a band.

    This class illustrates some important concepts of Python classes:
    - self
    - __init__()
    - __str__()
    - __eq__(self, other) is the equivalent of Java equals() and should be overridden in classes
    - __dict__ attribute of all objects
    - data fields (instance variables)
    - methods - calling them by self.<method>(...) from the same class where they are defined
    """

    def __init__(self, name, is_band_member=True):
        self.name = name
        self.is_band_member = is_band_member
        # self.__n = 'lll'                                    # 'private' field
        # self._m = 'mmm'
        # self.__immutable_property = 'I am immutable'

    def __str__(self):
        band_name_str = f'(band member)' if self.is_band_member else f'(solo musician)'
        return f'{self.name} {band_name_str}'

    def __eq__(self, other):
        t = isinstance(other, Musician)
        n = self.name == other.name if t else False
        b = self.is_band_member == other.is_band_member if t else False
        return t and n and b

    # Properties: 'private' fields/attributes:
    #   @property
    #   def <attr>(self):
    #       """ The docstring for <attr> must go here."""
    #       return self.__<attr>
    #   @<attr>.setter
    #   def <attr>(self, <attr>):
    #       self.__<attr> = <attr> if ... else ...
    #   @<attr>.deleter
    #   def <attr>(self, <attr>):
    #       del self.__<attr>

    # Properties allow programmers to create methods that behave like attributes.
    # With properties, one can change how they compute the target attribute whenever they need to do so.
    # A more detailed explanation: https://realpython.com/python-property/.
    # In general, avoid turning attributes that donâ€™t require extra processing into properties.
    # Using properties in those situations can make the code unnecessarily verbose, confusing and slower
    # than code based on regular attributes.

    # Make name a property (after setting up __init__(), __str__(), __eq__(), methods,...)

    # Run setters and getters in the debugger

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name if isinstance(name, str) else 'unknown'

    # Add an immutable property (no setter for it)
    # @property
    # def immutable_property(self):
    # return self.__immutable_property

    def play(self, song_title, *args, **kwargs):
        """Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, rhythm counts, expressions of gratitude and messages. A call example:
            <musician>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        Convention: if rhythm count is provided, it is passed as rhythm_count='...' and is the first kwarg.
        """

        rhythm_count = ' - ' + kwargs['rhythm_count'] + ' - ' if 'rhythm_count' in kwargs.keys() else ''
        g = ' '.join([g for g in args]) if args else ''
        if 'rhythm_count' in kwargs.keys():
            del kwargs['rhythm_count']              # if not deleted, it will appear in m (see the next line)
        m = ' '.join([v for v in kwargs.values()]) if kwargs else ''
        return f'{self.name} playing {song_title}{rhythm_count}... (playing) ... {g} {m}'

    def play_song(self, song_title, *args, **kwargs):
        """Demonstrates calling another method from the same class (self.<method>(...) as a mandatory syntax).
        """

        return self.play(song_title, *args, **kwargs)

    # Alternative constructor
    @classmethod
    def from_str(cls, musician_string):
        """Inverted __str__() method.
        Assumes that musician_string is in the format generated by __str__().
        """

        # band_name_str = f'(band member)' if self.is_band_member else f'(solo musician)'
        # return f'{self.name} {band_name_str}'
        n = musician_string.split('(')[0].rstrip()
        b = musician_string.split('(')[1].startswith('b')
        return cls(n, b)


